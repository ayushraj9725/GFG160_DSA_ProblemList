Problem : Largest Divisible Subset

Problem Statement : 

Given an array arr[] of distinct positive integers. Your task is to find the largest subset such that for every pair of elements (x, y) in the subset, either x divides y or y divides x.
Note : If multiple subsets of the same maximum length exist, return the one that is lexicographically greatest, after sorting the subset in ascending order.

Examples:

Input: arr[] = [1, 16, 7, 8, 4]
Output: [1, 4, 8, 16]
Explanation: The largest divisible subset is [1, 4, 8, 16], where each element divides the next one. This subset is already the lexicographically greatest one.

Input: arr[] = [2, 4, 3, 8]
Output: [2, 4, 8]
Explanation: The largest divisible subset is [2, 4, 8], where each element divides the next one. This subset is already the lexicographically greatest one.

Constraint:
1 ≤ arr.size() ≤ 103
1  ≤ arr[i] ≤ 109

Expected Complexities
Time Complexity: O(n^2)
Auxiliary Space: O(n)

Company Tags
Bloomberg  Facebook  Adobe  Google  Amazon Apple  Microsoft  Yahoo

/***************************************************************************** SOLUTIONS DIFF TYPES ***************************************************************/

////////////////////   BRUTE FORCE TO OPTIMIZATIONSS BELOW   //////////////////


[Naive Approach] Generate all subset of array - O(2^n*n^2) Time and O(n) Space



[Better Approach] Using Recursion - O(2^n*n) Time and O(n) Space



[Expected Approach 1] Using Top-Down DP(Memoization) - O(n^2) Time and O(n) Space



[Expected Approach 2] Using Bottom-Up DP (Tabulation) – O(n^2) Time and O(n) Space


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Main function to find the largest divisible subset
vector<int> largestSubset(vector<int> &arr) {
	
  	int n  = arr.size();
    sort(arr.rbegin(), arr.rend());

    // Table to store the size of largest subset
    vector<int> dp(n, 1);

    // To keep track of previous elements
    vector<int> parent(n, -1);

    // Fill dp table
    int maxSize = 1;
    int lastIndex = 0;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[j] % arr[i] == 0 && dp[i] < dp[j] + 1) {
                dp[i] = dp[j] + 1;
                parent[i] = j;
            }
        }

        // Update maxSize and lastIndex
        if (dp[i] > maxSize) {
            maxSize = dp[i];
            lastIndex = i;
        }
    }

    // Backtrack to construct the subset
    vector<int> res;
    for (int i = lastIndex; i >= 0; i = parent[i]) {
        res.push_back(arr[i]);
        if (parent[i] == -1)
            break;
    }

    return res;
}


int main() {
    vector<int> arr = {1, 16, 7, 8, 4};

    vector<int> res = largestSubset(arr);
	for (int num : res) {
        cout << num << " ";
    }

    return 0;
}